"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
var LogIncomingRequestMiddleware_1;
const core_1 = require("@tsed/core");
const Express = require("express");
const ts_log_debug_1 = require("ts-log-debug");
const ServerSettingsService_1 = require("../../config/services/ServerSettingsService");
const request_1 = require("../../filters/decorators/request");
const response_1 = require("../../filters/decorators/response");
const middleware_1 = require("../decorators/class/middleware");
/**
 * @middleware
 */
let LogIncomingRequestMiddleware = LogIncomingRequestMiddleware_1 = class LogIncomingRequestMiddleware {
    // tslint:disable-next-line: no-unused-variable
    constructor(serverSettingsService) {
        this.AUTO_INCREMENT_ID = 1;
        this.loggerSettings = serverSettingsService.logger;
        this.reqIdBuilder = this.loggerSettings.reqIdBuilder || (() => this.AUTO_INCREMENT_ID++);
        this.fields = this.loggerSettings.requestFields || LogIncomingRequestMiddleware_1.DEFAULT_FIELDS;
        this.debug = serverSettingsService.debug;
    }
    /**
     * Handle the request.
     * @param {e.Request} request
     * @param {e.Response} response
     */
    use(request, response) {
        this.configureRequest(request);
        this.onLogStart(request);
        core_1.applyBefore(response, "end", () => this.onLogEnd(request, response));
    }
    /**
     * The separate onLogStart() function will allow developer to overwrite the initial request log.
     * @param {e.Request} request
     */
    onLogStart(request) {
        request.log.debug({ event: "start" });
    }
    /**
     * Attach all informations that will be necessary to log the request. Attach a new `request.log` object.
     * @param request
     */
    configureRequest(request) {
        request.id = String(request.id ? request.id : this.reqIdBuilder());
        request.tsedReqStart = new Date();
        const { ignoreUrlPatterns = [] } = this.loggerSettings;
        const regs = ignoreUrlPatterns.map((pattern) => (typeof pattern === "string" ? new RegExp(pattern, "gi") : pattern));
        const verbose = (req) => this.requestToObject(req);
        const info = (req) => this.minimalRequestPicker(req);
        const run = (cb) => {
            const match = regs.find(reg => !!request.url.match(reg));
            return !match && cb();
        };
        request.log = {
            info: (obj) => run(() => ts_log_debug_1.$log.info(this.stringify(request, info)(obj))),
            debug: (obj) => run(() => ts_log_debug_1.$log.debug(this.stringify(request, verbose)(obj))),
            warn: (obj) => run(() => ts_log_debug_1.$log.warn(this.stringify(request, verbose)(obj))),
            error: (obj) => run(() => ts_log_debug_1.$log.error(this.stringify(request, verbose)(obj))),
            trace: (obj) => run(() => ts_log_debug_1.$log.trace(this.stringify(request, verbose)(obj)))
        };
    }
    /**
     * Return complete request info.
     * @param request
     * @returns {Object}
     */
    requestToObject(request) {
        return {
            reqId: request.id,
            method: request.method,
            url: request.originalUrl || request.url,
            duration: this.getDuration(request),
            headers: request.headers,
            body: request.body,
            query: request.query,
            params: request.params
        };
    }
    /**
     * Return a filtered request from global configuration.
     * @param request
     * @returns {Object}
     */
    minimalRequestPicker(request) {
        const info = this.requestToObject(request);
        return this.fields.reduce((acc, key) => {
            acc[key] = info[key];
            return acc;
        }, {});
    }
    /**
     * Return the duration between the time when LogIncomingRequest has handle the request and now.
     * @param request
     * @returns {number}
     */
    getDuration(request) {
        return new Date().getTime() - request.tsedReqStart.getTime();
    }
    /**
     * Stringify a request to JSON.
     * @param request
     * @param propertySelector
     * @returns {(scope: any) => string}
     */
    stringify(request, propertySelector) {
        return (scope = {}) => {
            if (typeof scope === "string") {
                scope = { message: scope };
            }
            scope = Object.assign(scope, propertySelector(request));
            try {
                return JSON.stringify(scope, null, this.loggerSettings.jsonIndentation);
            }
            catch (er) {
                ts_log_debug_1.$log.error({ error: er });
            }
            return "";
        };
    }
    /**
     * Called when the `request.end()` is called by Express.
     * @param request
     * @param response
     */
    onLogEnd(request, response) {
        setImmediate(() => {
            /* istanbul ignore else */
            if (request.id) {
                if (this.loggerSettings.logRequest) {
                    request.log.info({ status: response.statusCode });
                }
                if (this.debug) {
                    request.log.debug({
                        status: response.statusCode,
                        data: request.getStoredData && request.getStoredData()
                    });
                }
                this.cleanRequest(request);
            }
        });
    }
    /**
     * Remove all data that added with `LogIncomingRequest.configureRequest()`.
     * @param request
     */
    cleanRequest(request) {
        delete request.id;
        delete request.tagId;
        delete request.tsedReqStart;
        request.log = {
            info: () => { },
            debug: () => { },
            warn: () => { },
            error: () => { },
            trace: () => { }
        };
    }
};
LogIncomingRequestMiddleware.DEFAULT_FIELDS = ["reqId", "method", "url", "duration"];
tslib_1.__decorate([
    tslib_1.__param(0, request_1.Req()), tslib_1.__param(1, response_1.Res()),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
], LogIncomingRequestMiddleware.prototype, "use", null);
LogIncomingRequestMiddleware = LogIncomingRequestMiddleware_1 = tslib_1.__decorate([
    middleware_1.Middleware(),
    tslib_1.__metadata("design:paramtypes", [ServerSettingsService_1.ServerSettingsService])
], LogIncomingRequestMiddleware);
exports.LogIncomingRequestMiddleware = LogIncomingRequestMiddleware;

//# sourceMappingURL=LogIncomingRequestMiddleware.js.map
